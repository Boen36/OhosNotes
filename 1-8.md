# 资源分类与访问

资源分为应用资源和系统资源。

资源的目录结构分为两类：资源目录和资源组目录

资源目录有base目录，限定词目录，rawfile目录，resfile目录。rawfile目录下的文件以原始形式打包进应用，不分配资源ID，resfile目录下的文件在安装时会解压到应用的沙箱路径

资源组目录有element，media, profile

资源目录和资源组目录下的文件都属于资源文件，在打包时不会进行混淆保护。

profile目录下的配置文件属于资源文件，只能为json格式，因为它的兼容性和稳定性更好

json5的文件更灵活，更适用于开发阶段的配置文件。json文件格式更严格，兼容性更好，更适用于资源文件，通常属于应用运行时的一部分

profile目录用于存放动画文件（AE导出的动画配置文件json格式），布局模板文件($r('app.profile.layout.common_header'))

base和限定词目录下的资源文件会被编译为二进制文件，并分配资源ID。通过指定资源类型(type)和资源名称(name)来访问

## 资源目录

限定词表示特定的使用场景和设备特征。建议使用IDE提供的资源目录创建工具

rawfile和resfile目录都支持多层子目录，资源文件不经过编译，也不会分配资源ID。rawfile中的资源直接被打包进应用，通过指定文件URL访问。resfile中的资源会被解压到应用沙箱路径。可以通过Context的resourceDir获取resfile目录路径，该路径只能以只读方式访问

## 资源组目录

资源组目录包括element，media，profile三类资源文件

element存放页面元素资源，数据类型可以是string, boolean, color, float, intarray, integer, strarray, string，plural(复数)

plural复数类型的资源文件的典型应用例子。英文中一条评论翻译为one comment，多条评论为 three comments，中文表示都一样。

```
{
"plural": [
    {
        "name": "eat_apple",
        "value": [
            {
                "quantity": "one",
                "value": "%d apple"
            },
            {
                "quantity": "other",
                "value": "%d apples"
            }
        ]
    }
]
}
```

media目录下的音视频支持.3gp和.mp4两种格式，3gp格式用于必须兼容老旧协议的特殊场景，鸿蒙开发首选mp4格式

字符串资源文件中的字符串支持attr属性

```
"attr": {
    "translatable": true,
    "priority": "code" 未翻译 ｜ "translate" 翻译未验证 | "LT" 翻译已验证 | "customer" 用户定制字符串
}
```

## 资源访问

### 单包资源访问

`$r('app.type.name', 'aaa', 'bbb')`，`$rawfile('filename')`

`getContext().resourceManager.getStringByNameSync('test')`

`getContext().resourceManager.getRawFd('rawfilePath')`

### 跨HAP/HSP包应用资源

createModuleContext(context, moduleName) 可以创建应用中不同module的上下文，然后通过resourceManager的资源接口访问

引用hsp模块内的资源时，可以使用`$r('[hsp].type.name')` hsp 为 hsp 模块名，必须写在[]中

访问HSP的rawfile资源，`$rawfile('[hsp].oneFile/twoFile/test.png')`

使用$r和$rawfile跨包访问资源时，无法提供编译时的资源校验，需要开发者自行保证资源的合法性

### 获取系统资源

系统资源包括系统图标资源，系统颜色资源，系统间距圆角等资源.

通过主题图标库获取系统Symbol资源，通过SymbolGlyph可以对图标颜色进一步设置。Symbol是符号的意思，Glyph是符号的视觉表现形式

系统颜色资源通过「系统色彩全量表」获取

通过`$r('sys.type.name')`访问系统资源

系统默认字体为鸿蒙黑体，如果要显示的字符超出了鸿蒙黑体的显示范围，系统会选择优先级最高的支持显示该符号的字体。系统字体的优先级设计，可以在设备的system/etc/fontconfig.json配置文件中查看

## 资源匹配规则

系统根据当前设备状态，优先从匹配的限定词目录中寻找资源，如果没有匹配的限定词目录，则从base目录中寻中资源。

rawfile和resfile原始文件中的目录不会根据设备状态匹配

### 限定词目录与设备状态的匹配规则

限定词目录名中所有的限定规则要与设备状态完全匹配

整体按照范围从大到小的规则，移动国家码 > 移动网络码 > 区域 > 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度

### 获取指定配置的资源

```
const resMgr = this.getUIContext().getHostContext()?.getResourceManager()
let overrideCfg = resMgr.getOverrideConfiguraton()
overrideCfg.locale = 'en'
const overideResourceMgr = resMgr.getOverrideResourceManager()
overrideResourceMgr.getStringSync($r('app.string.hello').id)
```

### overlay机制

在不重新打包发布的情况下，实现应用界面风格变换，类似与皮肤资源。overlay资源包只包含资源文件，资源索引文件和配置文件.

overlay分为静态overlay和动态overlay。静态overlay就像默认主题，在安装的时候默认安装，动态overlay就像下载/卸载主题

动态overlay主要通过获取overlay资源路径，来动态的使用资源。

overlay资源包需要放在应用安装根目录下，通过`getContext().bundleCodeDir`获取应用沙箱根目录，通过resourceManager的addResource(path)和removeResource(path)来添加和移除资源.

静态overlay通过配置需要覆盖的模块名，实现资源的覆盖。主要通过`module.json5`中的`targetModuleName`和`targetPriority`标签配置
