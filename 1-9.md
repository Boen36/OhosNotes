# 学习ArkTS语言

ArkTS在JS/TS的生态上做拓展。在TS的基础上，进一步通过规范强化静态检查和分析，一方面在编译时能够提早发现更多问题，另一方面减少了运行时的类型检查，提升了执行性能

ArkTS支持与标准的JS/TS高效互操作，可以高效复用JS/TS的代码

ArkTS规范约束TS中过于灵活的特性，这些特性会影响开发的正确性或者给运行时带来不必要的开销。由此可以在静态分析阶段获取更确定和稳定的信息.

ArkTS在TS的基础上对并发进行了增强，并且定义了一套UI范式

ArkTS规范约束的特性主要有几下几种:

1. 不支持在运行时修改对象布局

在运行时支持修改对象布局，需要很大的运行时开销。可以通过ArkTS的可选属性或者将字段设为undefined来代替

2. 不支持缺少类型标注的对象字面量

对象字母量缺少类型，编译器变无法知道该对象的具体类型，以及其中字段的相关约束，编译器缺少这些关键的信息，便无法对这段代码进行深度优化。

3. 不支持structural typing

ArkTS支持nominal typing，即根据具体的声明来判断两个类型是否兼容，而不是通过结构。structural typing的方式无法将对象的属性访问优化为固定偏移量的形式，因为它是通过结构来判断两个类型是否兼容，也就是说两个对象的结构可能是完全不同的，便无法使用固定偏移量的优化

4. 限制运算符语义

例如加法运算符只能用于数字

ArkTS的一大特性是低运行时开销

## 类型

ArkTS的基础类型是直接访问的，引用类型通过引用访问。拿快递柜举例，直接访问指的是直接打开对应的柜子，引用访问指的是通过取件码找到要打开的柜子

ArkTS中string类型属于基础类型

Number.MAX_VALUE 可以表示的最大正数

Number.MAX_SAFE_INTEGER 可以表示的最大正整数

如何理解转义字符中的转义二字。转义字符英文为escape，直译为逃脱，指的是这个符号“逃脱”原有的解释规则。转义也就是转换含义，标识\之后的字符需要转换含义

void是引用类型，只有一个值void，用于指定函数没有返回值。

void可以用于范型类型参数，表示该类型的范型字段或属性为空

```
class Class<T> {
...
}
let instance: Class<void>
```

Object类型用于标识除基本类型外的所有类型

Object 是所有引用类型的基类型，任何值，包括基础类型的值都可以直接赋值给Object类型的变量，基本类型的值会被自动装箱

enum 枚举类型属于值类型，值类型指的是它的枚举常量是基础类型，直接访问数据本身。枚举常量又称为命名值

```
enum Color {Red, Green, Blue}

enum Mode {A = 1, B = 2, C = 3} // 可以显示设置枚举常量的值
```

可以使用instanceof匹配Union联合类型中的特定类型值

Aliases类型为类型提供别名`type Matrix = number[][]`

== 比较值是否相等，=== 比较值和类型是否都严格相等

```
let a: Object = 1
let b: Object = '1'
a == b // true 值相等
a === b // false 值相等，类型不想等
```

if (expresson) 条件表达式可以是任何类型，非boolean类型会自动进行隐式转换为boolean

expression ? a : b expression可以进行隐式转换为boolean

for-of语句可以遍历可迭代的类型，例如数组，Set，Map，字符串

可以break中断指定的位置
```
label: while(true) {
    switch(x) {
        case 1:
            break label
    }
}
```

函数重载，需要将多个函数签名写在一起，在单一函数中实现重载

```
foo(a: number);
foo(a: string);
foo(a: number | string) {}
```

实例化类通过new关键字或者对象字面量创建

ArkTS要求类的所有非空字段必须在声明时或构造函数中显示初始化，对于允许为空的字段是允许不初始化的

类中的getter和setter提供了对字段的受控访问

```
class Person {
    private _age: number = 1
    set age(a: number) {
        this._age = a_
    }
    get age() {
        return this._age
    }
}
```

静态方法定义了类作为一个整体的公共行为

基类又称为父类，派生类又称为子类

重写父类方法的返回类型可以为原有返回类型的派生类

可见性修饰符，private，public，protected，默认为public，public可以理解为不受任何限制。private 修饰的成员只能在定义的类中访问。protected修饰的成员除了可以在定义的类中访问，还可以被子类访问。

对象字母类只能在可以推导出它类型的地方使用，没有类型的对象字母量是非法的

Record<K, V> K可以为string和number基础类型，V可以为任何类型

```
let record: Record<string, number> = {
    "boen": 12,
    "rhyme": 23
}
```

只有抽象类才能有抽象方法

接口是定义代码协定的方式，任何类只要实现了接口，都可以通过该接口实现多态

属性字段是getter和setter的简写

```
interface Style {
    color: string
}
interface Style {
    set color(c: string)
    get color()
}
```

> 抽象类和接口的区别

抽象类捕捉子类的通用特性强调is-a，接口是行为的抽象，强调can-do。因此一个类只能继承一个抽象类，却能够实现多个接口就可以很好理解了，继承的语义是is-a，一个类的父类只能有一个，但是一个类的行为却可以有多个。抽象类更像类。因此抽象类可以有方法实现，可以有构造函数，可以有静态代码块和静态方法。但是接口中只有行为的定义，它无法包含方法的实现，没有构造函数，没有类的定义，也就无法拥有静态特性.

> 范型约束

```
class MyHashMap<K extends Hashable, V> {

}
```

范型参数可以有默认值

> 空安全

一个类型只有明确包含null，才可以赋值为null，否则将会编译错误

```
let a: string = null // 编译错误
let a: string | null = null // 需要显示的声明类型可能为null
```

非空断言运算符!，断言可控类型的值不会为空，如果在运行时为空，则会发生运行时异常

```
class A {
    value: number
}
function foo(a: A | nul) {
    a!.value
}
```

空值合并运算符??

```
foo(a: number | null) {
    return a ?? 3
}
```


a ?? b 等同于 `(a != null && a != undefined) ? a : b`

可选链 a?.b?.c

### 模块

模块是编译单元。每个模块都有其自己的作用域，模块中的资源和声明需要显示的导出才可被外界访问

使用export导出顶层的声明。顶层就是顶层作用域

静态导入`import * as Utils from 'xxx'`

当需要根据条件导入模块或者需要按需导入时，使用动态导入的特性`import()`

```
import(modulePath).then((obj: ESObject) => {
    // obj包含了导入模块的所有导出信息
})
```

在ArkTS中，ESObject是在动态导入时用于表示模块导出对象的通用类型，源码中`ESObject = any`

```
import {UIAbility} from '@kit.AbilityKit'
import UIAbility from 'ohos.app.ability.UIAbility'
```

kit对原来的ohos模块进行了整理，分为了不同的kit，便于文档查看和管理

`import * as module from '@kit.AbilityKit'` 会导入过多无需的资源，导致编译后的HAP体积太大

顶层语句是指位于顶层作用域中的语句，位于模块的最外层，不被任何作用域包裹

### this关键字

this指向调用方法的实例对象或者正在构造的对象

### 注解

`@interface`用于声明一个注解

```
@interface ClassAuther {
    name: string
}
@ClassAuther({name: 'boen'})
class MyClass {

}
```

注解声明可以导出，多个注解的先后顺序对使用没有影响，注解可以理解为自定义的元数据，在原有声明基础上补充元数据

注解字段只支持string, boolean, enum，number，以及这些类型的数组，其中enum的枚举值需要在编译时能够确定

因为注解只有在编译期发挥作用，可以理解为注解在编译时提供额外的信息

注解只能定义在顶层作用域

当前仅支持对类和方法添加注解

不允许对import的注解进行重命名

`import type`只用于编译时的静态类型检查，只引入类型信息，不引入实际代码到运行时

在`.d.ets`文件中声明自定义注解类型
`export declare @interface ClassAuther { name: string }`

注解不会被继承

不支持对抽象类和抽象方法添加注解，因为注解只在编译时发挥作用，需要在具体的环境中发挥作用
